# 项目完结总结

### 1.注册页面

注册页面只需进行表单验证，验证手机号必须是1开头的11位数字，验证码校验只需判断是否是6位，如果表单全部验证成功会重新发起请求带手机号、验证码、密码三个参数发送给服务器，并跳转到登录页面。

### 2.登录页面

**业务逻辑**

用户输入账号和密码，点击登录按钮后，前端获取表单数据后发送给服务器，服务器判定是否存在该用户，以及密码是否正确。如果判断是对的，则跳转到home页面，否则进行错误提示。

**具体实现**

当用户登录成功后，服务器会为了区分是谁下发一个token。当我们点击登录按钮之后就会向服务器发起请求，并且获取到token值。（正常情况下，向服务器发起登录请求之后我们只能获取到token值，然后我们再通过token获取用户信息）

通过token获取用户信息,我们将token放在请求拦截器中。在项目中我们都会二次封装axios，二次封装的目的就是使用请求/响应拦截器，token放在请求头中携带发送非常方便。

```vue
//请求拦截器：在发请求之前，请求拦截器可以检测到，可以在请求发出去之前做一些事情
requests.interceptors.request.use((config)=>{
    //config：配置对象，对象里面有一个属性很重要，header请求头
    //进度条开始动
    nprogress.start();
    if(store.state.detail.uuid_token){
        //请求头中添加一个字段（userTempId），已经和后台老师商量好了
        config.headers.userTempId = store.state.detail.uuid_token
    }
    //需要携带token，将其带给服务器
    if(store.state.user.token){
        config.headers.token = store.state.user.token
    }
    return config;
});
```

但是存在于vuex中的token不是持久化的，当我们刷新页面之后获取到的token就会消失。

```v
//持久化存储token
localStorage.setItem("TOKEN", result.data.token)
```

### 3.退出登录

当用户退出登录时，需要向服务器发送请求，服务器需要清除用户数据。基于token的方式实现退出比较简单，只需要销毁本地的token即可。

虽然发送请求不需要返回数据，但依旧需要实现完整的vuex三连环，因为要清空state中的token数据。

### 4.导航守卫

导航守卫需要解决的问题1. 未登录状态下，用户是不能访问购物车页面的2.登录状态下，用户是不能访问登录页面的

首先，在全局前置守卫中，限制登录状态下用户是不能访问登录页面。那怎么才能判断用户是否登录了呢？只要vuex中有了token，就代表用户已经登陆了。因此我们需要在全局前置守卫中拿到token。

### 5.项目路由分析

项目结构分为上、中、下三部分：

路由组件：Home首页路由组件、Search搜索路由组件、login登录路由组件、注册路由组件

非路由组件包括：Header组件【出现在首页、搜索、登录、注册】、Footer组件【出现在首页、搜索页】（注册为全局组件）

### 6.三级联动

商品分类三级联动组件拆分成全局组件，因为在多个路由组件中用到。拆分成全局组件想在哪用都可以。

### 7.axios二次封装

二次封装axios的目的是使用请求拦截器和响应拦截器，使axios更适合我们的项目

1.引入axios 2.创建axios实例 3.请求/响应拦截器 4.对外暴露

### 8.接口统一管理

如果项目规模较小，完全可以在组件的生命周期函数中发送请求，如果项目规模较大不利于后期维护，便统一管理接口。

发送请求之后会出现404的错误，这里的是跨域问题。采用代理服务器去解决，在vue.config.js中进行配置

```vue
module.exports = {
  //打包时不要有map文件
  productionSourceMap:false,
  //关闭校验工具
  lintOnSave:false,
  //代理跨域
  devServer:{
    proxy:{
      '/api':{ //遇到带有api的请求，代理服务器才会将其转发
        target:'http://gmall-h5-api.atguigu.cn',
        // pathRewrite:{'^/api':''},
      }
    }
  }
}
```

### 9.vuex模块开发

项目很小的就不需要vuex，项目较大就需要vuex进行数据的统一管理

新建store文件夹，存放index.js文件，此文件是引入vuex，安装vuex插件,引入各个小仓库，

```
//安装插件
Vue.use(Vuex);
```

对外暴露仓库

```vue
//对外暴露仓库
//第一个注意:需要关键字new，你没有new会报错的
//第二个注意:Store构造函数,书写的时候别小写
export default new Vuex.Store({
    //大仓库需要注册全部小仓库
    //vuex新增的一个配置项:模块式开发.右侧V也是对象
    modules: {
        home,
        search,
        detail,
        user,
        shopcart,
        trade
    }
})
```

### 10.防抖和节流

防抖：前面的所有的触发都被取消，最后一次执行在规定时间之后才会触发，也就是说如果连续快速地触发，只会执行一次。

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。

三级联动页面添加节流的代码，节流采用插件lodash，

为什么要采用节流呢？在三级联动页面如果鼠标移动过快，就会多次向服务器发送请求，就会出现卡顿现象。

### 11.合并参数

从主页的三级联动页面跳转到对应的搜索页面会携带有参数，如果继续在搜索页搜索东西就会携带新的parmas参数。

如果路由跳转时带有params参数，要和query参数一块传递过去

### 12.mock.js模拟数据

我们可以通过mock模拟一些数据，组件中的轮播图路径采用mock模拟数据。mock数据json格式

### 13.swiper轮播图

安装swiper，new Swiper实例之前页面中一定要有结构，因为我们要操作dom.

**重点：**

我们应该在哪new swiper呢，这时我们就会想到生命周期，放在mounted()钩子函数中。但是写完之后会发现没有效果，轮播图并没有出现。

那是为什么呢？那是因为结构还不够完整。轮播图不只是一张图片，我们使用v-for遍历图片，图片数据是通过axios请求获得，发送请求需要一定的时间，所以在我们初始化swiper实例的时候结构还不够完整。

我们可以使用`watch+nextTick()`函数，在下次DOM更新循环结束之后，执行延迟回调。在修改数据之后，立即使用这个方法，获取更新后的DOM.

### 14.滚动行为

当我们点击进入一个较长的页面中，正常情况下应该保留在页面的最顶部，这个效果该如何实现呢？

```
//index.js文件
import routes from './routes'
 
//配置路由 对外暴露VueRouter类的实例
let router = new VueRouter({
    //配置路由 （k,v一致，可以省略v）
    routes,
    //滚动行为
    scrollBehavior(to,from,savedPosition){
        //返回的这个y=0,代表的滚动条在最上方
        return {y:0}
        
    }
}); 
export default router;
```

### 15.放大镜效果

实现的方式是两张图片，一张小尺寸另一张是较大尺寸，最开始大图片是隐藏的，当蒙版移动到小图片上之后，对应的大图片部分进行展示。
